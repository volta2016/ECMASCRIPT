# Event Lopp

## source

[source](https://kriyavikalpa.com/2022/02/12/javascript-quick-revision-2/)

## C√≥mo funciona realmente javascript ?

Buenos hemos escuchado del V8, el Runtime de chrome pero nada sab√≠a
a ciencia cierta qu√© era o que hac√≠a. Tambi√©n hemos escuchado sobre monoprocesos o callback

## Javascrip qu√© rayos eres ?

Soy un lenguaje de monoproceso concurrente.
Yo Tengo:

- Call Stack
- Event Loop
- callback queue

caracteristicas del lenguaje:

- single threaded
- non blocking
- asynchronous
- concurrent

Tengo un:

- callstack
- heap o memory heap

Si miramos un runtime de Javascript como V8, que es el runtime de chrome
este es una imagen simplificada de lo que es el runtime en JS

![heap-stack](./images/heap-stack.png)

## Heap

Es donde se produce la asignaci√≥n de memoria y la pila de llamadas

heap (asignaci√≥n de memoria) - stack (pila de tareas o llamadas)

el V8 puede hacer varias cosas como:
setTimeout, DOM y HTTP Request y ver√°s que no est√°n all√≠, no existen en
V8. Es algo extra√±o conocer al principio, porque setTimeout lo primero que usas cuando piensas en cosas as√≠ncronas y no estan dentro del v8

lo que hay que entender que tenemos el runtime del v8 pero esas cosas que se llaman as√≠ncronas son las **Web Apis** y que son otras cosas que nos proporciona el navegador

![heap-stack](./images/event-loop.png)

tenemos el m√≠tico event loop y el callback queue(cola de callbacks)

## the call stack

one thread == one callstack == one thing at a time

JavaScript es un lenguaje de programaci√≥n monoproceso, con un runtime monoproceso y una sola pilla de llama (call stack)

- **Puedo hacer una cosa a la vez, que es lo que significa monoproceso,
  que el programa puede ejecutar una porci√≥n de c√≥digo a la vez**

**Call Stack**

Como podemos ver tenemos alguna funciones como un multiplicador:

- multiply: multiplica dos n√∫meros
- square: llama a la funci√≥n multiplicar por el mismo n√∫mero
- printSquare: una funci√≥n que imprime el cuadrado llamando una funci√≥n y haciendo luego un console.log
- al final de nuestro archivo ejecutamos printSquare(4)

![call-stack](./images/callstack.png)

Si ejecutamos esto:
basicmante el call stack es una estructura de datos que registra en que parte del programa que estamos

si ejecutamos este archivo hay una funci√≥n main() que viene a ser el propio archivo y eso se mete en la pila, luego tenemos alguna definiciones de funciones y al final tenemos printSquare(4)

eso llama a funci√≥n -> printSquare(n)

![printSquar](./images/printSquare.png)

vamos dentro de printSquare se mete en la pila -> square(n)

![printSquar](./images/square.png)

llama a multiply ahora tenemos un return multiplicamos a y b y regresamos
cuando retornamos sacamos algo de la pila

volvemos a imprimir printSquare(n) en el console.log() no hay retorno es impl√≠cito

![printSquar](./images/multiply.png)

finalmente terminamos y se ve as√≠

![printSquar](./images/finish.png)

## otro ejemplo

Si es que estamos desarrollando desde el navegador tenemos un c√≥digo como este

tambi√©n has escuchado sobre desbordar la pila este es un ejemplo

![printSquar](./images/callstack2.png)

Si tienes una funci√≥n foo que llama a foo

qu√© crees que va pasar ?
tenemos a baz, que llama a bar, que llama a foo, que tira un error si lo ejecutamos en chrome

- RangeError

vemos que imprime Ooops! justo el estado de la pila cuando se produjo el error, un error no controlado. Al final chrome dice no creo que quieras llamar a foo 16.000 de forma recursiva asi que me cargar√© esto por ti para que puedas buscar el error

## blocking

Qu√© pasa cuando las cosas van lentas lentas?

Hablamos de bloqueos y comportamientos de bloqueos, realmente no hay una
definici√≥n estricta de lo que es o no, nos referimos a que el c√≥digo va muy lento.

console.log() no es lento, pero hacer un while de uno a diez mil millones si es lento.

- Las peticiones de red son lentas
- descargar im√°genes son lentas

**cuando algo lento entra en la pila de llamadas es cuando hablamos de bloqueos**

un ejemplo esto es como c√≥digo falso getSynchronous

![getSync](./images/getSync.png)

es como jQuery como una solicitud AJAX

Qu√© pasar√≠a si estas solicitudes fueran s√≠ncronas?

üëÄ olvida lo que sabemos sobre callbacks as√≠ncronos, **ahora son s√≠ncronos**

si lo hacemos como antes **llamamos a getSync**

![getSync foo](./images/getSync-callstack.png)

esta haciendo una petici√≥n de red, la red entre diferentes equipos es lenta, si hay suerte, esa llamada red se completara y podremos seguir adelante, esperamos, seguimos adelante vamos con la segunda bar

![getSync bar](./images/qux.png)

al fin terminan estos 3 comportamientos de bloqueo completos y podemos limpiar la pila bien

![getSync bar](./images/getsync-log.png)

![getSync bar](./images/cleancallstack.png)

en un lenguaje de programaci√≥n de monoproceso hay que esperar, no se usan difernetes hilos como lo hace ruby.

Eso es lo que pasa hacemos una solicitud de red y tenemos que esperar a que termine, porque no hay otra forma de gestionar

## Por qu√© realmente es un problema?

El problema es ejecutar c√≥digo en los navegadores

vamos a ver un ejemplo anterior en el navegador:

cuando llama a foo veamos que sucede

![sincrono-callstack](./images/sincrono-callstack.png)

Los navegadores no nos dan solicitudes AJAX s√≠ncronas, las estamos imitando con un gran bucle while, que es s√≠ncrono, b√°sicamente espero 5 segundos ante de continuar y abrimos la consola

**si lllamamos a foo.com por qu√© pasa esto?**
no podemos hacer nada, hasta el bot√≥n de ejecutar no termina de renderizar el hecho de hacer click en √©l

- el navegador est√° bloqueando, se ha colgado no puede hacer nada hasta completar las solicitudes, luego todo va mal porque varias cosas y me di cuenta que se ejecutan al terminar el proceso y me di cuenta de su acci√≥n ya finalizando y ni siquiera podr√≠a renderizarlo. No puedo hacer nada.

![sincrono-callstack](./images/sincrono-callstack2.png)

## Entonces c√≥mo gestionamos esto ?

- La soluci√≥n m√°s simple es que tenemos los callbacks as√≠ncronos, as√≠ casi no tendremos funciones que cuelguen al navegador, como en node, que todo es as√≠ncrono lo que b√°sicamente significa que ejecutamos un c√≥digo le
  damos un callback y lo ejecutamos m√°s tarde

## Un ejemplo simple de como trabaja esto

![ejemplo](./images/example.png)

Escribe y ejecutamos setTimeout, pero eso mete el log en la cola para despu√©s as√≠ que pasamos a JSConf, cinco segundos despu√©s escribimos
**"there"**

Entonces c√≥mo funcionan los retornos de la llamadas as√≠ncronas con respecto a las pilas que vimos antes?

vamos a ejecutar el c√≥digo

![ejemplo](./images/console.log-hi.png)

sabemos que no se ejecutara inmediato, que tardar 5 segundos

No lo metemos en la pila simplemente sabemos que desaparece.

example

![ejemplo](./images/setTimeout.png)

registramos el console.log de JSConfEU, cinco segundos despu√©s m√°gicamente
aparece there en el stack

![ejemplo](./images/there.png)

## Concurrency y Event Loop

as√≠ es como el bucle de evento entra en **concurrencia**

## Primero veamos la diferencia entre estos conceptos

Concurrencia y paralelismo son conceptos relacionados pero con un importante matiz de diferencia entre ellos. Es por esto que muy a menudo se confunden y se utilizan err√≥neamente. Vayamos al grano:

**Concurrencia:** cuando dos o mas tareas progresan simult√°neamente.
**Paralelismo:** cuando dos o mas tareas se ejecutan, literalmente, a la vez, en el mismo instante de tiempo.

en realidad se miente un poco al decir que javascript solo puede hacer una sola cosa a la vez

- Es cierto que el Runtime de Javascript solo puede hacer una cosa a la vez no puede efectuar una solicitud AJAX. Mientras est√° ejecutando otro c√≥digo. No puedes hacer un
  setTimeout mientras se esta ejecutando el c√≥digo.

- Pero podemos hacer m√°s cosas al mismo tiempo porque el navegador es m√°s que el runtime

recordemos que este diagrama: el Runtime de Javascript puede hacer una cosa a la vez, pero el navegador nos da todo esto, nos da estas API, esto son efectivamente subprocesos a los que pueden hacer llamadas, y esas partes del navegador, que son conscientes de esta concurrencia

![hi](./images/hi.png)

si eres backend este diagrama es casi como en node: en lugar de API WEB tenemos API de C++ y nos oculta el subproceso

ahora que tenemos esta imagen vamos a ver como se ejecuta esto en el navegador:

igual que antes ejecuta el c√≥digo

- consonle.log() hi

![heap-stack](./images/setTimeout2.png)

- ahora vamos a ver que pasa con al llamar a setTimeout(), pasamos el callback de esta funci√≥n y un retraso a llamada setTimeout.

setTimeout es una API que nos proporciona el navegador no existe dentro del V8, son cosas de m√°s que obtenemos al ejecutar el Runtime de Javascript

![timer](./images/timer.png)

aqu√≠ el navegador inicia un temporizador y ahora gestiona la cuenta atr√°s, lo que significa nuestra llamada a setTimeout ya esta completa y podemos sacarla de la pila. JSConfEU, limpiar, ahora tenemos el temporizador en la API que se completar√° cinco segundos despu√©s. Pero la API web no puede simplemente cambiar nuestro c√≥digo, no puede meter cosas en la pila cuando le parezca si lo hiciera, aparecen cosas al azar en medio del c√≥digo, as√≠ que es donde entra en juego la cola de tarea o cola de callbacks(task queue)

Cualquiera de las API Web mete el callback en la cola de tareas cuando est√° lista, la empuja.

- Finalmente llegamos al **bucle de evento,** pues es como la piecesita m√°s sencilla de toda esta ecuaci√≥n y tiene un objetivo muy simple. \*\*El trabajo de bucle de eventos es observar la pila y cola de tareas. Si la pila est√° vac√≠a, coge la primero de la cola y lo mete en la pila, que efectivamente lo ejecuta.

![task-queue](./images/task-queue.png)

aqu√≠ podemos ver que, ahora la pila est√° limpia hay un callback en la cola de tareas, se se ejecuta el bucle de eventos, dice:
!oh, tengo cosas que hacer! mete callback en la pila

![callback in pila](./images/callback-in-pila.png)

Recuerda que la pila (stack) es terreno de javascript de vuelta al v8, aparece el callback en la pila ejecuta el console.lo()
"there" y hemos terminado

![finish-stack](./images/callback-in-pila.png)

## otro ejemplo setTimeout 0

vamos aplicar un setTimeout pero con 0, la raz√≥n es que en general intentas diferir algo hasta que la pila est√° limpia.

primero ejecuta:

hi
JSConf
there

setTimeout cero se completar√° de inmediato y lo meter√° en la cola, recordemos lo que mencionamos sobre el bucle de eventos, tiene que esperar que la pila este limpia antes de poder meter el callback en la pila para que este siga con la ejecuci√≥n -> para que siga con la ejecuci√≥n del console.log()

![setTimeout-cero](./images/setTimeout-cero.png)

"hi" "JSCONF" y limpiar, ahora el bucle de evento entra en acci√≥n y llama al callback

call-cb

![call-cb](./images/call-cb.png)

**Eso es un ejemplo de setTimeout con cero, es diferir esa ejecuci√≥n de c√≥digo, por el motivo que sea hasta el final de la pila hasta que la pila este limpia**

## solicitud Ajax

Entonces todas estas API Web funcionan igual, si tenemos una solicitud AJAX, hacemos la solicitud a la url con un callback, funciona igual.

console.log("Hi")
hace la solicitud AJAX -> El c√≥digo para ejecutar esa solicitud AJAX no vive en el runtime de Javascript pero si en navegador como API web, se lo lanzamos a la URL con un callback, **pero s√≠ en el navegador como API web, se lo lanzamos ala URL con un callback y nuestro c√≥digo puede seguir corriendo.**

Hasta que complete esa solicitud XHR que tal vez nunca se complete, no importa, la pila sigue ejecutando, suponiendo que se complete, se mete a la cola, lo recoge y el bucle de eventos de ejecuta

![callback-cb](./images/callback-cb.png)

![callback-cb-complete](./images/callback-cb-complete.png)

![bucle-of-event](./images/bucle-of-event.png)

Eso es todo lo que sucede cuando se produce una llamada as√≠ncrona

## vamos con un ejemplo m√°s complicado

vamos a ver le run time de JS

Como se puede ver en el c√≥digo, vamos a meter un addEventListener por aqu√≠. un setTimeout y luego un console.log().
Vamos a ejecutarlo y a ver que pasa, a√±adimos una API DOM, un setTimeout

```js
console.log("Started");

$.on("button", "click", function onClick() {
  console.log("Clicked");
});

setTimeout(function onTimeout() {
  console.log("Timeout finished");
}, 5000);

console.log("Done");
```

"tener en cuenta que el onclick es un Web Apis"

vamos a ejecutar el c√≥digo:

1. console.log("Started")

2. a√±adimos una API DOM con un un console.log()

3. console.log("Done");

4. a√±adimos un setTimeout el c√≥digo sigue ejecut√°ndose, mete el callback en cola -> se ejecuta y hemos terminado.
   Empuja el callback a callback Queue -> ejecuta y hemos terminado

si hago click varias veces podemos ver que pasa:

![clicked](./images/clicked.png)

he hecho click pero no se procesa de inmediato, (quedan varios procesos en el callback Queue) luego se mete al call Stack -> se procesa la cola en alg√∫n momento se tratara el click correcto

## Otro ejemplo con API as√≠ncronas

En este ejemplo llamamos a setTimeout cuatro veces con un segundo de retraso y un console.log()

```js
setTimeout(function timeout() {
  console.log("hi");
}, 1000);

setTimeout(function timeout() {
  console.log("hi");
}, 1000);

setTimeout(function timeout() {
  console.log("hi");
}, 1000);

setTimeout(function timeout() {
  console.log("hi");
}, 1000);
```

para cuando los callbacks entran en la cola(callback queue) ese cuarto callback tiene un segundo de retraso y todav√≠a est√° esperando el callback no se ha ejecutado cierto?

**üëÄ cuando entra el cuartoreci√©nn comienza a ejecutarse el primer
setTimeout**

![4-callbackqueue](./images/4-callbackqueue.png)

**Esto ilustra qu√© est√° haciendo no es un tiempo de ejecuci√≥n garantizado si no un tiempo m√≠nimo para la ejecuci√≥n al igual que el setTimeout 0 -> no ejecuta el c√≥digo inmediatamente sino que es lo siguiente que hace, cuando pueda**

## callbacks as√≠ncronos

Vamos hablar sobre los callbacks, los callbacks pueden ser cualquier funci√≥n que llama a otra funci√≥n o m√°s expl√≠citamente una devoluci√≥n de llamada as√≠ncrona que se meter√° en la cola de callbacks en el futuro.

Esta secci√≥n de c√≥digo muestra la diferencia, El m√©todo forEach en un array, no se ejecuta, toma una funci√≥n, que podr√≠a llamar a un callback pero no funciona de forma as√≠ncrona, si no dentro de la pila actual. Podr√≠amos definir un forEach as√≠ncrono que pudiera tomar un array y un callback, para cada elemento hiciera un setTimeout 0 con ese callback, en teor√≠a deber√≠a pasarle el valor, pero vamos a ejecutarlo as√≠ vemos cual es la diferencia

```js
//Synchronous
[1, 2, 3, 4].forEach(function (i) {
  console.log(i);
});

//Asynchronous

function asyncForEach(array, cb) {
  array.forEach(function () {
    setTimeout(cb, 0);
  });
}

asyncForEach([1, 2, 3, 4], function (i) {
  console.log(i);
});
```

- El primer bloque de c√≥digo que se ejecute se quedar√° ah√≠
  bloqueando la pila (call stack), **queda bloqueando el hilo**. Se ejecuta una vez por cada elemento
  hasta que se complete

![callstackbloq](./images/callstackbloq.png)

- Mientras que en la versi√≥n Async, cierto va m√°s lento, pero b√°sicamente vamos a meter un pu√±ado de callbacks y luego limpiamos el
  callback queue. Si podremos ejecutarlo y hacer console.log()

en este caso el console.log() es r√°pido por el beneficio de que sea as√≠ncrono no es obvio, pero si tuvi√©ramos un procesamiento lento por cada elemento del array

Asi que tengo un funci√≥n de retraso que es lenta, digamos procesando async y sync

```js
//Synchronous
[1, 2, 3, 4].forEach(function (i) {
  console.log("processing sync");
  delay();
});

//Asynchronous

function asyncForEach(array, cb) {
  array.forEach(function () {
    setTimeout(cb, 0);
  });
}

asyncForEach([1, 2, 3, 4], function (i) {
  console.log("processing async", i);
  delay();
});
```

Vamos a simular el repintado o el renderizado en el navegador, b√°sicamente el navegador est√° limitado por lo que hace javaScript, el navegador quiere volver a pintar la pantalla cada 16,6 milisegundos
60 cuadros por segundo es lo ideal, Es lo mas r√°pido que intentara de repintar si lo dejan hacer.

Pero est√° limitado en Javascript por varias razones, as√≠ que no puede realmente renderizar nada si no hay c√≥digo en la pila (call stack) cierto.

Digamos que el tipo de llamada del render es casi como un callback en si mismo, tiene que esperar que la cola de tareas callback queue este vac√≠a. La diferencia es que el renderizado tiene mayor prioridad que nuestros callbacks cada 16 ms va a poner en cola un render esperar√° hasta que la pila est√© vaci√° y entonces har√° el redibujado.

As√≠ que esto esta en cola renderizado solo simula un renderizado cada segundo, puedo renderizar por eso el prende y apaga el color verde

![render-queue](./images/render-queue.png)

D√≥nde... porque ahor amismo nuestro c√≥digo no est√° haciendo nada.

Si ejecuto el c√≥digo, mientras recorremos este bucle s√≠ncrono lento a trav√©s del array.

### Vemos que nuestro render est√° bloqueando, si est√° bloqueando no se puede seleccionar el texto en pantalla, no se puede hacer click y ver la respuesta, como el ejemplo que vimos antes

delay() est√° bloqueando

En este ejemplo, est√° bloqueando mientras ponemos en cola el setTimeout as√≠ncrono que es relativamente r√°pido, pero en cierto modo, estamos dando al render una oportunidad entre cada elemento, por que lo pusimos en la cola as√≠ncronamente para saltar all√≠ y hacer el renderizado.

Entonces este es una simulaci√≥n de c√≥mo funciona el renderizado.

Pero que nos ense√±an por qu√© la gente nos dice, oye no bloquees el bucle de eventos, te dicen que no te metas ese c√≥digo tan lento en la pila porque si lo haces, el navegador no har√° lo que debe hacer como crear una interfaz de usuario fluida y agradable. Es por eso que cuando procesamos im√°genes o animaciones demasiadas cosas y dem√°s.
Si no tiene cuidado de como se mete ese codigo en la cola, va ir tan lento

## Podemos ver un ejemplo con los scroll o barras de desplazamiento

```js
function animatedSomething() {
  delay();
}

$.on("document", "scroll", animatedSomething);
```

estas barras generan un mont√≥n de eventos de desplazamiento en el DOM, hay muchas que se disparan, como 1 vez cada 16ms, si tengo un codigo como este.

document.scroll -> animar algo o hacer alg√∫n trabajo.

![document-scroll](./images/document-scroll.png)

Si ejecuto este c√≥digo, cuando me desplace se podr√°n en cola como miles de callbacks.

Luego tiene que ir procesar cada uno de ellos, son sumamente lentos, no est√°s bloqueando la pila, solo est√°s inundando la cola de tareas, esto nos permite visualizar, espero lo que realmente sucede cuando se activan todos estos callbacks, hay forma de evitarlos, vamos poner todos esos eventos en cola pero vamos hacer el trabajo lento cada poco segundos o hasta que el usuario deje de desplazarse cierta cantidad de tiempo.
